"""Unit tests for Equipment & Gear Management MCP Tools.

These tests verify the equipment management, gear recommendations, maintenance 
tracking, and optimization strategy tools work correctly with proper user context 
management and error handling.
"""

import pytest
import json
import uuid
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, patch

# Import the tools to test
from maratron_ai.equipment_gear_tools import (
    analyze_shoe_rotation_tool,
    get_gear_recommendations_tool,
    track_equipment_maintenance_tool,
    optimize_gear_selection_tool,
    plan_equipment_lifecycle_tool
)


class TestShoeRotationAnalysis:
    """Test shoe rotation analysis tools."""

    @pytest.fixture
    def mock_user_context(self):
        """Mock user context for tests."""
        with patch('maratron_ai.equipment_gear_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture  
    def mock_pool(self):
        """Mock database pool."""
        pool = AsyncMock()
        with patch('maratron_ai.equipment_gear_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def sample_shoes(self):
        """Sample shoe collection for testing."""
        return [
            {
                'id': str(uuid.uuid4()),
                'name': 'Nike Air Zoom Pegasus',
                'currentDistance': 150.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=60)
            },
            {
                'id': str(uuid.uuid4()),
                'name': 'Adidas Ultraboost',
                'currentDistance': 380.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=120)
            },
            {
                'id': str(uuid.uuid4()),
                'name': 'Brooks Ghost 15',
                'currentDistance': 50.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=15)
            }
        ]

    @pytest.fixture
    def sample_runs_with_shoes(self):
        """Sample runs with shoe tracking."""
        shoe_ids = [str(uuid.uuid4()), str(uuid.uuid4()), str(uuid.uuid4())]
        return [
            {
                'shoeId': shoe_ids[0],
                'shoe_name': 'Nike Air Zoom Pegasus',
                'distance': 5.0,
                'date': datetime.now() - timedelta(days=1)
            },
            {
                'shoeId': shoe_ids[1],
                'shoe_name': 'Adidas Ultraboost',
                'distance': 6.0,
                'date': datetime.now() - timedelta(days=2)
            },
            {
                'shoeId': shoe_ids[0],
                'shoe_name': 'Nike Air Zoom Pegasus',
                'distance': 4.0,
                'date': datetime.now() - timedelta(days=3)
            }
        ]

    @pytest.mark.unit
    async def test_analyze_shoe_rotation_no_shoes(self, mock_user_context, mock_pool):
        """Test shoe rotation analysis with no shoes."""
        mock_pool.fetch.side_effect = [[], []]  # No shoes, no runs

        result = await analyze_shoe_rotation_tool()

        assert "Shoe Rotation Analysis" in result
        assert "No shoes found" in result
        assert "addShoe()" in result

    @pytest.mark.unit
    async def test_analyze_shoe_rotation_success(self, mock_user_context, mock_pool, sample_shoes, sample_runs_with_shoes):
        """Test successful shoe rotation analysis."""
        mock_pool.fetch.side_effect = [sample_shoes, sample_runs_with_shoes]

        result = await analyze_shoe_rotation_tool()

        assert "Shoe Rotation Analysis" in result
        assert "Your Collection:" in result
        assert "Rotation Health:" in result
        assert "Individual Shoe Status:" in result
        assert "Optimization Recommendations:" in result
        assert "Nike Air Zoom Pegasus" in result

    @pytest.mark.unit
    async def test_analyze_shoe_rotation_single_shoe(self, mock_user_context, mock_pool, sample_runs_with_shoes):
        """Test shoe rotation analysis with single shoe."""
        single_shoe = [sample_shoes[0] for sample_shoes in [[{
            'id': str(uuid.uuid4()),
            'name': 'Only Shoe',
            'currentDistance': 200.0,
            'maxDistance': 400.0,
            'retired': False,
            'createdAt': datetime.now() - timedelta(days=30)
        }]]][0]
        
        mock_pool.fetch.side_effect = [single_shoe, sample_runs_with_shoes]

        result = await analyze_shoe_rotation_tool()

        assert "Shoe Rotation Analysis" in result
        assert "Consider adding a second pair" in result or "rotation" in result.lower()

    @pytest.mark.unit
    async def test_analyze_shoe_rotation_high_usage_shoes(self, mock_user_context, mock_pool, sample_runs_with_shoes):
        """Test shoe rotation analysis with high usage shoes."""
        high_usage_shoes = [{
            'id': str(uuid.uuid4()),
            'name': 'Worn Out Shoe',
            'currentDistance': 380.0,
            'maxDistance': 400.0,
            'retired': False,
            'createdAt': datetime.now() - timedelta(days=150)
        }]
        
        mock_pool.fetch.side_effect = [high_usage_shoes, sample_runs_with_shoes]

        result = await analyze_shoe_rotation_tool()

        assert "Shoe Rotation Analysis" in result
        assert ("95%" in result or "retire" in result.lower()) or "replacement" in result.lower()


class TestGearRecommendations:
    """Test gear recommendation tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.equipment_gear_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.equipment_gear_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def sample_user_data(self):
        return {
            'id': 'test-user-123',
            'name': 'Test Runner',
            'trainingLevel': 'intermediate'
        }

    @pytest.fixture
    def sample_runs(self):
        return [
            {'distance': 5.0, 'date': datetime.now() - timedelta(days=1)},
            {'distance': 8.0, 'date': datetime.now() - timedelta(days=3)}
        ]

    @pytest.fixture
    def sample_shoes_collection(self):
        return [
            {
                'name': 'Nike Pegasus',
                'currentDistance': 200.0,
                'maxDistance': 400.0,
                'retired': False
            },
            {
                'name': 'Brooks Ghost',
                'currentDistance': 100.0,
                'maxDistance': 400.0,
                'retired': False
            }
        ]

    @pytest.mark.unit
    async def test_get_gear_recommendations_no_user(self, mock_user_context, mock_pool):
        """Test gear recommendations without user data."""
        mock_pool.fetchrow.return_value = None

        result = await get_gear_recommendations_tool('general', 'current')

        assert "‚ùå User profile not found" in result

    @pytest.mark.unit
    async def test_get_gear_recommendations_racing_scenario(self, mock_user_context, mock_pool, sample_user_data, sample_runs, sample_shoes_collection):
        """Test gear recommendations for racing scenario."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.side_effect = [sample_runs, sample_shoes_collection]

        result = await get_gear_recommendations_tool('racing', 'summer')

        assert "Gear Recommendations - Racing (Summer)" in result
        assert "Priority Items:" in result
        assert "Racing flats" in result or "lightweight trainers" in result
        assert "race-day" in result.lower()

    @pytest.mark.unit
    async def test_get_gear_recommendations_long_runs(self, mock_user_context, mock_pool, sample_user_data, sample_runs, sample_shoes_collection):
        """Test gear recommendations for long runs."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.side_effect = [sample_runs, sample_shoes_collection]

        result = await get_gear_recommendations_tool('long_runs', 'fall')

        assert "Gear Recommendations - Long_runs (Fall)" in result
        assert "Hydration" in result or "hydration" in result
        assert "Cushioned" in result or "cushioned" in result

    @pytest.mark.unit
    async def test_get_gear_recommendations_speed_work(self, mock_user_context, mock_pool, sample_user_data, sample_runs, sample_shoes_collection):
        """Test gear recommendations for speed work."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.side_effect = [sample_runs, sample_shoes_collection]

        result = await get_gear_recommendations_tool('speed_work', 'spring')

        assert "Gear Recommendations - Speed_work (Spring)" in result
        assert "Lightweight" in result or "responsive" in result
        assert "form" in result.lower()

    @pytest.mark.unit
    async def test_get_gear_recommendations_trails(self, mock_user_context, mock_pool, sample_user_data, sample_runs, sample_shoes_collection):
        """Test gear recommendations for trails."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.side_effect = [sample_runs, sample_shoes_collection]

        result = await get_gear_recommendations_tool('trails', 'winter')

        assert "Gear Recommendations - Trails (Winter)" in result
        assert "Trail" in result or "traction" in result
        assert "protection" in result.lower()

    @pytest.mark.unit
    async def test_get_gear_recommendations_current_season(self, mock_user_context, mock_pool, sample_user_data, sample_runs, sample_shoes_collection):
        """Test gear recommendations with current season auto-detection."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.side_effect = [sample_runs, sample_shoes_collection]

        result = await get_gear_recommendations_tool('general', 'current')

        assert "Gear Recommendations - General" in result
        # Should auto-detect current season


class TestEquipmentMaintenance:
    """Test equipment maintenance tracking tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.equipment_gear_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.equipment_gear_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def maintenance_shoes(self):
        """Shoes at different maintenance stages."""
        return [
            {
                'name': 'Need Replacement',
                'currentDistance': 390.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=180)
            },
            {
                'name': 'Upcoming Maintenance',
                'currentDistance': 320.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=90)
            },
            {
                'name': 'Good Condition',
                'currentDistance': 100.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=30)
            },
            {
                'name': 'Old Shoe',
                'currentDistance': 200.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=400)
            }
        ]

    @pytest.mark.unit
    async def test_track_equipment_maintenance_no_equipment(self, mock_user_context, mock_pool):
        """Test equipment maintenance tracking with no equipment."""
        mock_pool.fetch.return_value = []

        result = await track_equipment_maintenance_tool('shoes')

        assert "Equipment Maintenance Tracker" in result
        assert "No equipment found" in result

    @pytest.mark.unit
    async def test_track_equipment_maintenance_shoes(self, mock_user_context, mock_pool, maintenance_shoes):
        """Test equipment maintenance tracking for shoes."""
        mock_pool.fetch.return_value = maintenance_shoes

        result = await track_equipment_maintenance_tool('shoes')

        assert "Equipment Maintenance Tracker (Shoes)" in result
        assert "Immediate Replacement Needed:" in result
        assert "Replacement Soon:" in result
        assert "Good Condition:" in result
        assert "Replacement Schedule:" in result

    @pytest.mark.unit
    async def test_track_equipment_maintenance_all(self, mock_user_context, mock_pool, maintenance_shoes):
        """Test equipment maintenance tracking for all equipment."""
        mock_pool.fetch.return_value = maintenance_shoes

        result = await track_equipment_maintenance_tool('all')

        assert "Equipment Maintenance Tracker (All)" in result

    @pytest.mark.unit
    async def test_track_equipment_maintenance_unsupported_type(self, mock_user_context, mock_pool):
        """Test equipment maintenance tracking for unsupported type."""
        result = await track_equipment_maintenance_tool('bicycles')

        assert "not yet supported" in result
        assert "shoes" in result


class TestGearSelection:
    """Test gear selection optimization tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.equipment_gear_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.equipment_gear_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def selection_shoes(self):
        """Shoes for selection testing."""
        return [
            {
                'name': 'Nike Speed Racer',
                'currentDistance': 50.0,
                'maxDistance': 300.0,
                'retired': False
            },
            {
                'name': 'Brooks Cushion Max',
                'currentDistance': 200.0,
                'maxDistance': 400.0,
                'retired': False
            },
            {
                'name': 'Adidas Light Runner',
                'currentDistance': 350.0,
                'maxDistance': 400.0,
                'retired': False
            }
        ]

    @pytest.fixture
    def sample_user_profile(self):
        return {
            'id': 'test-user-123',
            'trainingLevel': 'intermediate'
        }

    @pytest.fixture
    def recent_runs_sample(self):
        return [
            {'distance': 5.0, 'date': datetime.now() - timedelta(days=1)},
            {'distance': 8.0, 'date': datetime.now() - timedelta(days=3)}
        ]

    @pytest.mark.unit
    async def test_optimize_gear_selection_no_shoes(self, mock_user_context, mock_pool, sample_user_profile, recent_runs_sample):
        """Test gear selection with no shoes."""
        mock_pool.fetch.side_effect = [[], []]
        mock_pool.fetchrow.side_effect = [sample_user_profile]

        result = await optimize_gear_selection_tool('easy', 5.0)

        assert "Gear Selection for Easy Run (5.0 miles)" in result
        assert "No active shoes found" in result

    @pytest.mark.unit
    async def test_optimize_gear_selection_easy_run(self, mock_user_context, mock_pool, selection_shoes, sample_user_profile, recent_runs_sample):
        """Test gear selection for easy run."""
        mock_pool.fetch.side_effect = [selection_shoes, recent_runs_sample]
        mock_pool.fetchrow.return_value = sample_user_profile

        result = await optimize_gear_selection_tool('easy', 5.0)

        assert "Gear Selection for Easy Run (5.0 miles)" in result
        assert "Recommended:" in result
        assert "Why:" in result or "reasoning" in result.lower()

    @pytest.mark.unit
    async def test_optimize_gear_selection_tempo_run(self, mock_user_context, mock_pool, selection_shoes, sample_user_profile, recent_runs_sample):
        """Test gear selection for tempo run."""
        mock_pool.fetch.side_effect = [selection_shoes, recent_runs_sample]
        mock_pool.fetchrow.return_value = sample_user_profile

        result = await optimize_gear_selection_tool('tempo', 6.0)

        assert "Gear Selection for Tempo Run (6.0 miles)" in result
        assert "Recommended:" in result

    @pytest.mark.unit
    async def test_optimize_gear_selection_long_run(self, mock_user_context, mock_pool, selection_shoes, sample_user_profile, recent_runs_sample):
        """Test gear selection for long run."""
        mock_pool.fetch.side_effect = [selection_shoes, recent_runs_sample]
        mock_pool.fetchrow.return_value = sample_user_profile

        result = await optimize_gear_selection_tool('long', 15.0)

        assert "Gear Selection for Long Run (15.0 miles)" in result
        assert "Recommended:" in result

    @pytest.mark.unit
    async def test_optimize_gear_selection_race(self, mock_user_context, mock_pool, selection_shoes, sample_user_profile, recent_runs_sample):
        """Test gear selection for race."""
        mock_pool.fetch.side_effect = [selection_shoes, recent_runs_sample]
        mock_pool.fetchrow.return_value = sample_user_profile

        result = await optimize_gear_selection_tool('race', 10.0)

        assert "Gear Selection for Race Run (10.0 miles)" in result
        assert "Recommended:" in result


class TestEquipmentLifecycle:
    """Test equipment lifecycle planning tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.equipment_gear_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.equipment_gear_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def lifecycle_shoes(self):
        """Shoes at different lifecycle stages."""
        return [
            {
                'name': 'New Shoe',
                'currentDistance': 50.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=15)
            },
            {
                'name': 'Active Shoe',
                'currentDistance': 200.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=90)
            },
            {
                'name': 'Retiring Soon',
                'currentDistance': 360.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=180)
            },
            {
                'name': 'Retired Shoe',
                'currentDistance': 400.0,
                'maxDistance': 400.0,
                'retired': True,
                'createdAt': datetime.now() - timedelta(days=365)
            }
        ]

    @pytest.fixture
    def lifecycle_user_data(self):
        return {
            'id': 'test-user-123',
            'weeklyMileage': 25
        }

    @pytest.fixture
    def lifecycle_runs(self):
        """Recent runs for lifecycle analysis."""
        runs = []
        for i in range(10):
            runs.append({
                'distance': 5.0,
                'date': datetime.now() - timedelta(days=i*3)
            })
        return runs

    @pytest.mark.unit
    async def test_plan_equipment_lifecycle_no_shoes(self, mock_user_context, mock_pool, lifecycle_user_data):
        """Test equipment lifecycle planning with no shoes."""
        mock_pool.fetch.side_effect = [[], []]
        mock_pool.fetchrow.return_value = lifecycle_user_data

        result = await plan_equipment_lifecycle_tool()

        assert "Equipment Lifecycle Planning" in result
        assert "No shoes found" in result

    @pytest.mark.unit
    async def test_plan_equipment_lifecycle_success(self, mock_user_context, mock_pool, lifecycle_shoes, lifecycle_user_data, lifecycle_runs):
        """Test successful equipment lifecycle planning."""
        mock_pool.fetch.side_effect = [lifecycle_shoes, lifecycle_runs]
        mock_pool.fetchrow.return_value = lifecycle_user_data

        result = await plan_equipment_lifecycle_tool()

        assert "Equipment Lifecycle Planning" in result
        assert "Current Inventory:" in result
        assert "Replacement Timeline:" in result
        assert "Optimization Advice:" in result
        assert "Budget Planning:" in result

    @pytest.mark.unit
    async def test_plan_equipment_lifecycle_urgent_replacements(self, mock_user_context, mock_pool, lifecycle_user_data, lifecycle_runs):
        """Test lifecycle planning with urgent replacements."""
        urgent_shoes = [
            {
                'name': 'Urgent Replacement',
                'currentDistance': 395.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=180)
            }
        ]
        
        mock_pool.fetch.side_effect = [urgent_shoes, lifecycle_runs]
        mock_pool.fetchrow.return_value = lifecycle_user_data

        result = await plan_equipment_lifecycle_tool()

        assert "Equipment Lifecycle Planning" in result
        assert "üö®" in result or "high" in result.lower()


class TestHelperFunctions:
    """Test helper functions used by equipment gear tools."""

    def test_analyze_rotation_patterns(self):
        """Test shoe rotation pattern analysis."""
        from maratron_ai.equipment_gear_tools import _analyze_rotation_patterns
        
        shoes = [
            {
                'id': 'shoe1',
                'name': 'Shoe 1',
                'currentDistance': 200.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=60)
            },
            {
                'id': 'shoe2',
                'name': 'Shoe 2',
                'currentDistance': 100.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=30)
            }
        ]
        
        runs = [
            {'shoeId': 'shoe1'},
            {'shoeId': 'shoe2'},
            {'shoeId': 'shoe1'}
        ]
        
        analysis = _analyze_rotation_patterns(shoes, runs)
        
        assert 'total_shoes' in analysis
        assert 'active_shoes' in analysis
        assert 'rotation_health' in analysis
        assert analysis['total_shoes'] == 2

    def test_generate_gear_recommendations_function(self):
        """Test gear recommendation generation."""
        from maratron_ai.equipment_gear_tools import _generate_gear_recommendations
        
        recommendations = _generate_gear_recommendations(
            'racing', 'summer',
            {'trainingLevel': 'intermediate'},
            [],
            []
        )
        
        assert 'priority_items' in recommendations
        assert 'clothing' in recommendations
        assert 'accessories' in recommendations
        assert 'shoes' in recommendations

    def test_generate_gear_selection_advice(self):
        """Test gear selection advice generation."""
        from maratron_ai.equipment_gear_tools import _generate_gear_selection_advice
        
        shoes = [
            {
                'name': 'Speed Shoe',
                'currentDistance': 100.0,
                'maxDistance': 300.0
            },
            {
                'name': 'Cushioned Shoe',
                'currentDistance': 200.0,
                'maxDistance': 400.0
            }
        ]
        
        advice = _generate_gear_selection_advice(
            'tempo', 6.0, shoes, 
            {'trainingLevel': 'intermediate'}, 
            []
        )
        
        assert 'recommended_shoe' in advice
        assert 'reasoning' in advice
        assert 'alternatives' in advice
        assert 'general_advice' in advice

    def test_analyze_equipment_lifecycle(self):
        """Test equipment lifecycle analysis."""
        from maratron_ai.equipment_gear_tools import _analyze_equipment_lifecycle
        
        shoes = [
            {
                'name': 'Test Shoe',
                'currentDistance': 300.0,
                'maxDistance': 400.0,
                'retired': False,
                'createdAt': datetime.now() - timedelta(days=120)
            }
        ]
        
        user_data = {'weeklyMileage': 20}
        recent_runs = [
            {'distance': 5.0, 'date': datetime.now()}
        ]
        
        lifecycle = _analyze_equipment_lifecycle(shoes, user_data, recent_runs)
        
        assert 'replacement_timeline' in lifecycle
        assert 'current_inventory' in lifecycle
        assert 'optimization_advice' in lifecycle
        assert 'budget_planning' in lifecycle


# Pytest configuration for equipment gear tools tests
if __name__ == '__main__':
    pytest.main([__file__, '-v', '--tb=short'])