"""Unit tests for Route & Environment MCP Tools.

These tests verify the route planning, weather analysis, environment optimization, 
and terrain-based training recommendation tools work correctly with proper user 
context management and error handling.
"""

import pytest
import json
import uuid
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, patch

# Import the tools to test
from maratron_ai.route_environment_tools import (
    analyze_environment_impact_tool,
    get_route_recommendations_tool,
    analyze_elevation_impact_tool,
    get_seasonal_training_advice_tool,
    optimize_training_environment_tool
)


class TestEnvironmentImpactAnalysis:
    """Test environment impact analysis tools."""

    @pytest.fixture
    def mock_user_context(self):
        """Mock user context for tests."""
        with patch('maratron_ai.route_environment_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture  
    def mock_pool(self):
        """Mock database pool."""
        pool = AsyncMock()
        with patch('maratron_ai.route_environment_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def environment_runs(self):
        """Sample runs with environment data."""
        return [
            {
                'id': str(uuid.uuid4()),
                'distance': 6.0,
                'duration': '00:48:00',
                'date': datetime.now() - timedelta(days=1),
                'trainingEnvironment': 'outdoor'
            },
            {
                'id': str(uuid.uuid4()),
                'distance': 5.0,
                'duration': '00:40:00',
                'date': datetime.now() - timedelta(days=3),
                'trainingEnvironment': 'treadmill'
            },
            {
                'id': str(uuid.uuid4()),
                'distance': 7.0,
                'duration': '00:56:00',
                'date': datetime.now() - timedelta(days=5),
                'trainingEnvironment': 'outdoor'
            },
            {
                'id': str(uuid.uuid4()),
                'distance': 4.0,
                'duration': '00:32:00',
                'date': datetime.now() - timedelta(days=7),
                'trainingEnvironment': 'indoor'
            },
            {
                'id': str(uuid.uuid4()),
                'distance': 8.0,
                'duration': '01:04:00',
                'date': datetime.now() - timedelta(days=9),
                'trainingEnvironment': 'outdoor'
            }
        ]

    @pytest.mark.unit
    async def test_analyze_environment_impact_insufficient_data(self, mock_user_context, mock_pool):
        """Test environment impact analysis with insufficient data."""
        mock_pool.fetch.return_value = [
            {'trainingEnvironment': 'outdoor', 'distance': 5.0}
        ]  # Only 1 run

        result = await analyze_environment_impact_tool('4weeks')

        assert "Environment Impact Analysis (4weeks)" in result
        assert "Need at least 5 runs" in result

    @pytest.mark.unit
    async def test_analyze_environment_impact_success(self, mock_user_context, mock_pool, environment_runs):
        """Test successful environment impact analysis."""
        mock_pool.fetch.return_value = environment_runs

        result = await analyze_environment_impact_tool('4weeks')

        assert "Environment Impact Analysis (4weeks)" in result
        assert "Training Environment Breakdown:" in result
        assert "Insights & Recommendations:" in result
        assert "outdoor" in result.lower()
        assert "treadmill" in result.lower()

    @pytest.mark.unit
    async def test_analyze_environment_impact_different_periods(self, mock_user_context, mock_pool, environment_runs):
        """Test environment impact analysis with different time periods."""
        mock_pool.fetch.return_value = environment_runs

        for period in ['2weeks', '8weeks', '12weeks']:
            result = await analyze_environment_impact_tool(period)
            assert f"Environment Impact Analysis ({period})" in result


class TestRouteRecommendations:
    """Test route recommendation tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.route_environment_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.route_environment_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def sample_user_data(self):
        """Sample user data for testing."""
        return {
            'id': 'test-user-123',
            'name': 'Test Runner',
            'trainingLevel': 'intermediate',
            'defaultDistanceUnit': 'miles'
        }

    @pytest.fixture
    def sample_runs(self):
        """Sample run data for testing."""
        return [
            {
                'distance': 5.0,
                'duration': '00:40:00',
                'date': datetime.now() - timedelta(days=1),
                'elevationGain': 100
            },
            {
                'distance': 8.0,
                'duration': '01:04:00',
                'date': datetime.now() - timedelta(days=3),
                'elevationGain': 200
            }
        ]

    @pytest.mark.unit
    async def test_get_route_recommendations_no_user(self, mock_user_context, mock_pool):
        """Test route recommendations without user data."""
        mock_pool.fetchrow.return_value = None

        result = await get_route_recommendations_tool('general', 5.0, 'any')

        assert "‚ùå User profile not found" in result

    @pytest.mark.unit
    async def test_get_route_recommendations_speed_training(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test route recommendations for speed training."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_route_recommendations_tool('speed', 4.0, 'any')

        assert "Route Recommendations" in result
        assert "Goal: Speed training" in result
        assert "Distance: 4.0 miles" in result
        assert "Flat, fast route" in result
        assert "Track or smooth pavement" in result

    @pytest.mark.unit
    async def test_get_route_recommendations_hills(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test route recommendations for hill training."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_route_recommendations_tool('hills', 6.0, 'any')

        assert "Route Recommendations" in result
        assert "Goal: Hills training" in result
        assert "Rolling hills" in result or "sustained climbs" in result
        assert "hill" in result.lower()

    @pytest.mark.unit
    async def test_get_route_recommendations_endurance(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test route recommendations for endurance training."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_route_recommendations_tool('endurance', 12.0, 'any')

        assert "Route Recommendations" in result
        assert "Goal: Endurance training" in result
        assert "Scenic, comfortable route" in result
        assert "hydration" in result.lower()

    @pytest.mark.unit
    async def test_get_route_recommendations_weather_conditions(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test route recommendations with weather conditions."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        conditions = ['hot', 'cold', 'rainy', 'windy']
        
        for condition in conditions:
            result = await get_route_recommendations_tool('general', 5.0, condition)
            assert "Route Recommendations" in result
            assert f"Conditions: {condition.title()}" in result

    @pytest.mark.unit
    async def test_get_route_recommendations_recovery(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test route recommendations for recovery runs."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_route_recommendations_tool('recovery', 3.0, 'any')

        assert "Route Recommendations" in result
        assert "Goal: Recovery training" in result
        assert "Easy, familiar route" in result
        assert "soft" in result.lower() or "forgiving" in result.lower()


class TestElevationImpactAnalysis:
    """Test elevation impact analysis tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.route_environment_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.route_environment_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def elevation_runs(self):
        """Sample runs with elevation data."""
        return [
            {
                'distance': 5.0,
                'elevationGain': 50,  # 10 ft/mile - flat
                'date': datetime.now() - timedelta(days=1)
            },
            {
                'distance': 6.0,
                'elevationGain': 180,  # 30 ft/mile - hilly
                'date': datetime.now() - timedelta(days=3)
            },
            {
                'distance': 4.0,
                'elevationGain': 60,  # 15 ft/mile - flat
                'date': datetime.now() - timedelta(days=5)
            },
            {
                'distance': 8.0,
                'elevationGain': 400,  # 50 ft/mile - hilly
                'date': datetime.now() - timedelta(days=7)
            },
            {
                'distance': 10.0,
                'elevationGain': 800,  # 80 ft/mile - mountainous
                'date': datetime.now() - timedelta(days=9)
            }
        ]

    @pytest.mark.unit
    async def test_analyze_elevation_impact_insufficient_data(self, mock_user_context, mock_pool):
        """Test elevation impact analysis with insufficient data."""
        mock_pool.fetch.return_value = [
            {'elevationGain': 100, 'distance': 5.0}
        ]  # Only 1 run

        result = await analyze_elevation_impact_tool()

        assert "Elevation Impact Analysis" in result
        assert "Need at least 5 runs" in result

    @pytest.mark.unit
    async def test_analyze_elevation_impact_success(self, mock_user_context, mock_pool, elevation_runs):
        """Test successful elevation impact analysis."""
        mock_pool.fetch.return_value = elevation_runs

        result = await analyze_elevation_impact_tool()

        assert "Elevation Impact Analysis" in result
        assert "Elevation Training Breakdown:" in result
        assert "Hill Training Recommendations:" in result
        assert "Flat runs" in result
        assert "Hilly runs" in result

    @pytest.mark.unit
    async def test_analyze_elevation_impact_mostly_flat(self, mock_user_context, mock_pool):
        """Test elevation analysis with mostly flat runs."""
        flat_runs = [
            {'distance': 5.0, 'elevationGain': 25, 'date': datetime.now() - timedelta(days=i)}
            for i in range(10)
        ]
        mock_pool.fetch.return_value = flat_runs

        result = await analyze_elevation_impact_tool()

        assert "Elevation Impact Analysis" in result
        assert "Add more hill training" in result or "hill" in result.lower()

    @pytest.mark.unit
    async def test_analyze_elevation_impact_mostly_hilly(self, mock_user_context, mock_pool):
        """Test elevation analysis with mostly hilly runs."""
        hilly_runs = [
            {'distance': 5.0, 'elevationGain': 200, 'date': datetime.now() - timedelta(days=i)}
            for i in range(10)
        ]
        mock_pool.fetch.return_value = hilly_runs

        result = await analyze_elevation_impact_tool()

        assert "Elevation Impact Analysis" in result
        assert ("flat" in result.lower() and "speed" in result.lower()) or "balance" in result.lower()


class TestSeasonalTrainingAdvice:
    """Test seasonal training advice tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.route_environment_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.route_environment_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def sample_user_data(self):
        return {
            'id': 'test-user-123',
            'name': 'Test Runner',
            'trainingLevel': 'intermediate'
        }

    @pytest.fixture
    def sample_runs(self):
        return [
            {'distance': 5.0, 'date': datetime.now() - timedelta(days=1)},
            {'distance': 8.0, 'date': datetime.now() - timedelta(days=3)}
        ]

    @pytest.mark.unit
    async def test_get_seasonal_training_advice_no_user(self, mock_user_context, mock_pool):
        """Test seasonal advice without user data."""
        mock_pool.fetchrow.return_value = None

        result = await get_seasonal_training_advice_tool('spring')

        assert "‚ùå User profile not found" in result

    @pytest.mark.unit
    async def test_get_seasonal_training_advice_spring(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test spring training advice."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_seasonal_training_advice_tool('spring')

        assert "Seasonal Training Guide - Spring" in result
        assert "Building base" in result or "preparing for racing" in result
        assert "Training Emphasis:" in result
        assert "Environmental Tips:" in result
        assert "Equipment Suggestions:" in result
        assert "Race Considerations:" in result

    @pytest.mark.unit
    async def test_get_seasonal_training_advice_summer(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test summer training advice."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_seasonal_training_advice_tool('summer')

        assert "Seasonal Training Guide - Summer" in result
        assert "Peak training" in result or "racing season" in result
        assert "heat" in result.lower()
        assert "hydration" in result.lower()

    @pytest.mark.unit
    async def test_get_seasonal_training_advice_fall(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test fall training advice."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_seasonal_training_advice_tool('fall')

        assert "Seasonal Training Guide - Fall" in result
        assert "Peak racing" in result or "goal achievement" in result
        assert "marathon" in result.lower()

    @pytest.mark.unit
    async def test_get_seasonal_training_advice_winter(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test winter training advice."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_seasonal_training_advice_tool('winter')

        assert "Seasonal Training Guide - Winter" in result
        assert "Base building" in result or "maintenance" in result
        assert "cold" in result.lower() or "ice" in result.lower()

    @pytest.mark.unit
    async def test_get_seasonal_training_advice_current(self, mock_user_context, mock_pool, sample_user_data, sample_runs):
        """Test current season training advice."""
        mock_pool.fetchrow.return_value = sample_user_data
        mock_pool.fetch.return_value = sample_runs

        result = await get_seasonal_training_advice_tool('current')

        assert "Seasonal Training Guide" in result
        # Should auto-detect current season


class TestTrainingEnvironmentOptimization:
    """Test training environment optimization tools."""

    @pytest.fixture
    def mock_user_context(self):
        with patch('maratron_ai.route_environment_tools.get_current_user_id') as mock_user, \
             patch('maratron_ai.user_context.context.get_current_user_id') as mock_user_2, \
             patch('maratron_ai.security.data_isolation.get_current_user_id') as mock_user_3, \
             patch('maratron_ai.user_context.context.get_current_user_session') as mock_session:
            mock_user.return_value = 'test-user-123'
            mock_user_2.return_value = 'test-user-123'
            mock_user_3.return_value = 'test-user-123'
            mock_session.return_value = {
                'user_id': 'test-user-123',
                'session_id': 'test-session-123',
                'started_at': datetime.now()
            }
            yield mock_user

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        with patch('maratron_ai.route_environment_tools.get_pool', return_value=pool):
            yield pool

    @pytest.fixture
    def mixed_environment_runs(self):
        """Sample runs with mixed environments."""
        return [
            {'trainingEnvironment': 'outdoor', 'distance': 6.0, 'date': datetime.now() - timedelta(days=1)},
            {'trainingEnvironment': 'outdoor', 'distance': 5.0, 'date': datetime.now() - timedelta(days=2)},
            {'trainingEnvironment': 'treadmill', 'distance': 4.0, 'date': datetime.now() - timedelta(days=3)},
            {'trainingEnvironment': 'outdoor', 'distance': 8.0, 'date': datetime.now() - timedelta(days=4)},
            {'trainingEnvironment': 'treadmill', 'distance': 3.0, 'date': datetime.now() - timedelta(days=5)},
        ]

    @pytest.mark.unit
    async def test_optimize_training_environment_no_runs(self, mock_user_context, mock_pool):
        """Test environment optimization with no runs."""
        mock_pool.fetch.return_value = []

        result = await optimize_training_environment_tool()

        assert "Training Environment Optimization" in result
        assert "No recent runs found" in result

    @pytest.mark.unit
    async def test_optimize_training_environment_success(self, mock_user_context, mock_pool, mixed_environment_runs):
        """Test successful environment optimization."""
        mock_pool.fetch.return_value = mixed_environment_runs

        result = await optimize_training_environment_tool()

        assert "Training Environment Optimization" in result
        assert "Current Environment Usage:" in result
        assert "Optimization Suggestions:" in result
        assert "outdoor" in result.lower()
        assert "treadmill" in result.lower()

    @pytest.mark.unit
    async def test_optimize_training_environment_single_environment(self, mock_user_context, mock_pool):
        """Test environment optimization with single environment."""
        single_env_runs = [
            {'trainingEnvironment': 'treadmill', 'distance': 5.0, 'date': datetime.now() - timedelta(days=i)}
            for i in range(10)
        ]
        mock_pool.fetch.return_value = single_env_runs

        result = await optimize_training_environment_tool()

        assert "Training Environment Optimization" in result
        assert "diversifying" in result.lower() or "consider" in result.lower()


class TestHelperFunctions:
    """Test helper functions used by route environment tools."""

    def test_analyze_environment_performance(self):
        """Test environment performance analysis."""
        from maratron_ai.route_environment_tools import _analyze_environment_performance
        
        runs = [
            {'trainingEnvironment': 'outdoor', 'distance': 6.0, 'pace': '8:00'},
            {'trainingEnvironment': 'outdoor', 'distance': 5.0, 'pace': '8:10'},
            {'trainingEnvironment': 'treadmill', 'distance': 4.0, 'pace': '7:50'},
            {'trainingEnvironment': 'treadmill', 'distance': 5.0, 'pace': '7:55'}
        ]
        
        analysis = _analyze_environment_performance(runs)
        
        assert 'outdoor' in analysis
        assert 'treadmill' in analysis
        assert analysis['outdoor']['count'] == 2
        assert analysis['treadmill']['count'] == 2

    def test_generate_route_recommendations(self):
        """Test route recommendation generation."""
        from maratron_ai.route_environment_tools import _generate_route_recommendations
        
        recommendations = _generate_route_recommendations(
            'speed', 5.0, 'hot', 
            {'trainingLevel': 'intermediate'}, 
            []
        )
        
        assert 'route_type' in recommendations
        assert 'surface' in recommendations
        assert 'terrain' in recommendations
        assert 'specific_advice' in recommendations

    def test_analyze_elevation_performance(self):
        """Test elevation performance analysis."""
        from maratron_ai.route_environment_tools import _analyze_elevation_performance
        
        runs = [
            {'distance': 5.0, 'elevationGain': 50},  # 10 ft/mile - flat
            {'distance': 6.0, 'elevationGain': 180}, # 30 ft/mile - hilly
            {'distance': 4.0, 'elevationGain': 240}  # 60 ft/mile - mountainous
        ]
        
        analysis = _analyze_elevation_performance(runs)
        
        assert 'flat_runs' in analysis
        assert 'hilly_runs' in analysis
        assert 'mountainous_runs' in analysis
        assert analysis['flat_runs']['count'] == 1
        assert analysis['hilly_runs']['count'] == 1
        assert analysis['mountainous_runs']['count'] == 1


# Pytest configuration for route environment tools tests
if __name__ == '__main__':
    pytest.main([__file__, '-v', '--tb=short'])